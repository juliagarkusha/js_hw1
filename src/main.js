// 'number' + 23 + 32
// відповідь = строка number2332
// чому? Бо оператор + в js це в першу чергу оператор конкатенації, і тільки в другу чергу - математична дія.
// Дії з операндами виконуються послідовно: 'number' + 23 => строка + число = строка(’number23’). Далі те ж саме, строка

// 41 + 1 + 'number'
// відповідь = строка 42number
// чому? послідовність дій: 41 + 1 (додавання чисел), потім конкатенація 42 + number, в результаті якої отримуємо строку

//null + 1
// відповідь число 1
// чому? при додаванні, js неявно приводить типи, в цьому випадку до числа, бо серед операндів немає строк.
// Number(null) це нуль, 0 + 1 = 1

//'five' + + 'two'
// відповідь - строка fiveNaN
// чому - + перед 'two' позглядається як унарний +, тобто спроба привести строку 'two' до числа, Number(two) це NaN
// далі строка 'five' плюс число NaN - конкатинація - пріоритетна дія, тому NaN буде приведено до строки

//2 && 7
// відповідь - число 7
// чому - оператор "логічне і" перевіряє на істинність вирази і повертає в данному випадку останнє true, оскільки всі вирази є true
// якби вираз повертав false, то повернувся би перший false. Наприклад таке 2 && 0 && 7 - повернуло би нуль

// +'40' + +'2'
// це дуже легко) буде число 42, бо унарні плюси перед строками приведуть їх до чисел в даному випадку,
// а 40 + 2 = 42 (ось це навіть не стала перевіряти в консолі)))).

// '10' - 5 === 6
// це також дуже легко. Буде false. Чому - вираз зліва поверне 5, тому що, якщо + це в першу чергу конкатенація, а в другу -
// математична дія, то мінус - це і в першу, і в другу чергу математична дія. 10 буде приведено до числа, 10 - 5 = 5
// === - це оператор рівності зі строгим порівнянням, він порівняє числа 5 і 6, які не є рівними, тому буде false

// true + false
// відповідь - число 1
// чому - в даній ситуації немає строк, тому js приведе дані вирази до чисел Number(true) поверне 1, а Number(false) - нуль
// 1 + 0 = 1

// '4px' - 3
// відповідь - NaN
// чому - мінус не виконує конкатенацію, він буде намагатись привести вирази відразу до чисел. Number(4px) поверне NaN,
// NaN мінус число поверне NaN

// '4' - 3
// відповідь - число 1
// чому - спочатку строку 4 буде приведено до числа, потім виконається звичайне віднімання 4 - 3

//'2' + 3 ** 2
// відповідь - строка 29
// чому - спочатку виконається віднесення до степеня 2 числа 3. Буде число 9. Далі відбудеться конкатенація
// '2' + 9 = 29

//12 / '6'
// відповідь - число 2
// чому - спочатку строка 6 буде приведена до числа, потім виконається ділення 2-х чисел

//23 + 42 + 'number'
// відповідь - строка 65number
// чому  - пояснення таке ж саме, як і для 2-го виразу (41 + 1 + 'number'), спочатку додавання, потім - конкатенація

//'10' + (5 === 6)
// відповідь - строка 10false
// чому - до строки 10 буде додано false, конкатенація - пріоритетна дія, приведення до чисел не буде

// 'number' + 15 + 3
// відповідь - строка number153
// чому - конкатенація - пріоритетна дія, приведення до чисел не буде

//undefined + 1
// відповідь - NaN
// чому - приведення до числа undefined поверне  NaN, а NaN + число повертає також NaN
